## 3장 타입,값,변수 ##

    프로그래밍 언어로 다룰 수 있는 값의 종류을 데이터 타입 이라고 한다.
    프로그램은 값이 유지될 필요가 있을때, 변수에 값을 할당(저장)한다.
    변수는 값에 대한 이름을 정의하고, 이 이름값을 참조한다.

## 타입 ##

- 원시타입 (*숫자,문자열,Boolean, null, undefined*)
- 객체타입 (일반적으로)
		<br>객체(즉 객체타입의 멤버)는 이름과 값을 갖는 프로퍼티의 집합이다.
        <br>객체는 순서가 없는 값들의 집합이며, 각 값에는 이름이 지정(named)되어 있다.



> 배열객체
> <br>순서가 있는 값들의 집합이면, 각 값에는 번호(index)가 부여된다.(7장)
> 
> 함수객체
> <br함수는 실행 코드를 가지고 있는 객체로서, 실행 코드를 수행하고 계산된 값을 반환한다.
> <br배열과 만찬가지로 함수는 일반 객체와 다를게 동작한다.(8장)
> 
> 생성자함수(9장)
> <br>새로 생성된 객체를 (new 연산자을 이용하여) 초기화하기 위해 사용되는 함수
> 
>     자바스크립트 인터프리터는 메모리 관리를 위해 자동으로 가비지 컬렉션을 수행한다.프로그램이 필요할 때 객체를 생성할 수 있고,
>     프로그래머는 이객체를 어떻게 해제할지 걱정할 필요가 없다. 객체에 더 이상 접근할 수 없을때(프로그램이 더 이상 객체를 참조하지
>     않을 때) 인터프리터는  객체가 다시 사용되지 않을거라 판단하고 자동으로 메모리에서 해제한다.
> 
> 객체지향(메서드)
> <br>자바스크립트는 객체지향 언어다. 넗은 의미에서 이는 , 다양한 타입의 값을 다루는 전역 함수를 정의해두기보다, 어떤 값과
> <br>작동하는 메소드을 해당 타입 스스로가 정의해둔다는 말이다.
> 
>     a.sort(); //sort(a)의 객체 지향 버전
> <br>기술적으로, 자바스크립트 객체만이 메서드를 소유한다. 하지만 숫자,문자열,블리언 값은 메셔드를 가진 것처럼 동작한다.
> <br>null,undefined는 자바스크립튼에서 유일하게 메서드를 가질 수 없는 값이다.

원시타입과 객체타입의 분류

1. 메서드를 가질 수 있는 타입과 그렇지 않은 타입
2. 수정 가능한 타입과 수정할 수 없는 타입
   <br> 수정 가능 타입 : 객체와 배열
   <br> 그외 타입 : 숫자,문자열, 블리언, null, undefined 

> 타입변환의 자유로움
> 타입이 정해져 있지 않음, 
> <br>변수에 어떤 타입의 값을 할당할 수 있고, 
> <br>나중에 같은 변수에 다른 타입의 값을 할당할 수 있다.
> <br>변수는 var 타입으로 선언



## 3.1 숫자 ##
정수값과 실수 값을 구분하지 않음 자바스크립트에서 모든 숫자를 실수로 표현
<br> 숫자는 변수에 할당하기도 하고 또는 있는 그대로 사용한다 이렇게 사용하는 숫자를 숫자리터럴이라고 한다.

### 정수 리터럴 ###
0
<br>3
<br>100000

0xff => 15*16 + 15 = 255 (16진수)
<br>0377 => 3*64 + 7*8 + 7 =255 (8진수)

엄격한 모드(Strict Mode) 에서는 8진수 리터럴을 명시적으로 금지한다.

### 부동 소수점 리터럴 ###
부동 소수점 리터럴은 소수점을 가질 수 있다
<br> 실수는 정수부분과 소수점,소수점 이하 부분으로 표현한다.

3.14
<br>2345.789
<br>.333333333333
<br>6.02e23 //6.02 x 1023
<br>1.4738223E-32 //1.4738223 X 10.32

### 산술 연산 ###
기본적인 산술 연산 +,-,*,/,%
<br> 더 복잡한 수치 연산은 Math 객체를 통해 지원
<br> Math.pow(2,53) //=> 2의 53승



산술연산 중 다음 연산을 에러로 발생시키지 않는다. Infinity
<br> 오버플로 => 산술 연산의 결과가 표현할 수 있는 가장 큰수도다 더 클 경우
<br> 언더플로 => 산술 연산의 결과가 표현할 수 있는 가장 작은 값보다 더 0에 가까울때 이런 경우에는 0을 리턴
<br>            만약 언더플로우가 음수에서 발생했다면 특수값인 '음의 0'을 반환한다.
<br> 0 으로 나누는 에러
<br> 0 을 0으로 나누는 것은 정의되지 않은 값을 갖고 그 결과로 숫자가 아닌 특수한 값을 가진다.
<br> 자바스크립트에서는 이러한 값을 NaN으로 출력한다.

### 이진 부동소수점과 반올림 오류 ###

    var x = .3 - .2;
    var y = .2 - .1;
    x == y           //false
    x == .1          //false
    y == .1          //true   

반올림 오류 때문에 .3의 근사치와 .2의 근사치는 .2와 .1의 근사치 만큼 정확하게 같지않다.
<br>이는 자바스크립트 언어가 가진 결함이 아니라 이진 부동소소점 숫자를 사용하기 때문이며,
<br>이진 부동소수점 숫자를 사용하는 프로그램밍 언어에서 볼 수 있는 공통적인 현상이다.
<br>또한 코드의 x와 y값은 서로 매운 근접하고 정닶(0.1)에 가까운 값이다.

### 날짜와 시간 ###
    var later = new Data(2013 ,0, 1, 17 ,10 ,30); //2013년1월17일 오후 5시 10분 30초
    later.getFullYear(); //2013
	...


## 3.2 텍스트 ##
### 문자리터럴 ###
"" //=> 빈문자열 : 문자가 없다
<br>'testing' 
<br>"3.14"

\ => 역슬래쉬 이용 
<br> "two\nlines" //한줄이 두줄로 표현된는 한 문자열

'You\'re right,  it can\'t be a quote' //=> 영어 단축형 표현

### 문자열 다루기 ###

    var s = "hello, world"
    s.charAt(0);  //h:0번째 문자
    s.charAt(s.length -1) //d 마지막 문자
	...
	s[0] //=> h
    s[s.length-1]  //=> d

### 패턴매칭 ###

	/^HTML/				=> 문자열 첫 부분에 문자 HTML 과 일치
	/[1-9][0-9]*/ 		=> 0이 아닌 숫자와 일치 , 아무 숫자나 뒤 따라온다.
	/\bjavascript\b/i 	=> "javascript"와 일치, 대소문자을 구분한다.

### 불리언 값 ###

    undefined
	null
	0
	-0
	NaNv
	"" //빈문자열

	위 값은 모두 false

### null 과 undefined ###
    null      => 값이 없음(No Value) , null 은 고유의 값 , 객체 뿐만 아니라 숫자, 문자에도 사용, typeof => Object
    undefined => 값 자체가 없다. 초기화 되지 않았거나 존재하지 않는 객체에 접근시 얻는 값, 즉 정의되지 않은 값이다. typeOf => "undefined"

    if( null == undefined ) //true   
    if( null === undefined ) //false 

	시스템 레벨에서 예기치 않거나 값이 없어서 에러를 나타낼 때 등에는 주로 undefined를 사용하고, 
    일반적인 프로그램 레벨에서 예상되는 값이 없을 때는 null 을 사용한다.

### 전역객체 ###
    전역 객체의 프로퍼티는 자바스크립트 프로그램 전역에서 사용할 수 있게 정의된 심벌이다.

### 래퍼객체 ###
new String(), new Number(), new Boolean()
<br>null 과 undefined는 래퍼 객체가 없다.(프로퍼티에 접근하려고하면 TypeError 발생)

    var s = "test"	//이 문자열을 사용한다.
	s.len = 4;		//문자열 프로퍼티에 값을 할당한다.
	var t = s.len;	//프로퍼티를 참조한다.

	이 코드를 실행해 보년 t는 undefined 이다. 2행은 생성된 임시 String 객체의 len 프로퍼티에 4를 할당한다.
    그리고 임시 객체를 회수한다. 3행은 기존 문자열과 같은 값을 가진 새로운 String 객체를 생성하고 len 프로퍼티를 읽으려고 한다.
    이 프로퍼티는 존재하지 않아서 undefined로 평가된다 이 코드는 여러분이 문자열이나 숫자,불리언 값에서 프로퍼티(혹은 메서드)의
    값을 읽으려고 할때 문자열 숫자 불리언 값이 객체처럼 동작하는 것을 보여준다. 하지만 프로퍼티에 어떤 값을 할당한다면, 
    무시될 것이다. 값ㅇㄹ 할당하는 것은 임시 객체에서 수행되며 지속되지 않는다.

### 원시 타입과 참조타입 ###
원시타입은 값을 수정할 수 없다.(문자열도 마찬가지임 복사값을 리턴한다.)
    
	var s = "hello";
    s.toUpperCase(); // HELLO
	s; 				 // hello

객체는 원시타입과 다르다 객체는 자신의 값을 변경할 수 있다.(mutable)
   
	var o = {x:1};
	o.x = 2;
    o.y = 3;

객체는 참조타입으로 불리는데 이는 자바스크립튼의 원시 타입과 구별된다.
<br>이 용어를 사용하자면, 객체 값은 참조다. 다시 말해, 객체는 참조로 비교된다고 할 수 있다.

    var a= [];
    var b = a;
    b[0] = 1;
    a[0]   	//==> 1
    a === b //==> true
    
### 타입 변환 ###

    10 + " objects" //==> "10 objects"
	"7" * "4"		//==> 28
	var n = 1 - "x" //==> NaN
	n + " objects"  //==> "NaN Objects" //NaN은 문자열 "NaN" 으로 변환된다.
	

	숫자변환은 숫자로 파싱할 수 있는 문자열은 숫자로 변환된다. 앞뒤 공백은 허용되지만, 공백이나 숫자가 아닌 문자들이 썩인 경우
    에는 문자열에서 숫자로 변환할때 NaN이 된다.
    true => 1 이 되고 false와 "" 빈문자열은 0으로 변환된다.
    예외적으로 null 과 undefined는 변환할 수 없다. TypeError 발생

### 변환과 동등 비교 ###
	
    null == undefined 	//true
    "0"  == 0			// "0" 이 숫자로 변환	
     0   == false		// "false"가 숫자로 변환
	"0"  == flase		// 둘다 숫자로 변환

#### 명시적 변환 ####

    Number("3") 	//==> 3
	String(false)	//==> "false"
	Boolean([])		//==> true
	Object(3)		//==> new Number(3)

null 과 undefined를 제외한 모든 값은 toString() 메서드를 가지고 잇으면 이 메서드의 결과 는 보통 String() 함수가 반환하는 값과 같다.

    var n= 17;
    binary_string = n.toString(2); //"10001";
    ...
	var n = 123456.789;
	n.toFiexed(0); 			//123457
	n.toFiexed(2); 			//123456.79
	n.toExponenital(1);		//1.2e+5
	n.toPrecision(4);		//1.234e+5

문자열을 Number() 변환 함수로 넘긴다면, 변환 함수는 문자열을 정수 혹은 실수 리터럴로 해석할 것이다.
하지만 Number() 함수는 10진수 정수로만 동작하고 숫자 리터럴의 일부가 문자를 허용하지 않는다.
한편 paserInt(), paserFloat() 함수는 리터럴의 일부가 아니어도 된다는 점에서 Number() 보다 좀더 유연하게 동작한다.

    parseInt("3 blind mice") 	// 3
	parseFloat(" 3.14 meters") 	// 3.14
	parseInt(".1")				// NaN: 정수는 "."로 시작할 수 없다.
	parseFloat("$72.47")		// NaN: 숫자는 "$" 로 시작할 수 없다.
	
	paseInt("11",2);			//3 ( 1*2 + 1 )
	
#### 객체 타입에서 원시 타입으로 변환 ####


### 변수 선언 ###
    var i;
    var i, sum;
	var message = "hello";
	var i=0, j=0;k=0;

	var 구문에서 변수에 초기 값을 지정하지 않는다면, 변수는 값이 설정될때 까지 undefined 다.

    for( var i=0; i < 10; i++ ) console.log(i)


### 변수의 유효범위 ###

    var scope = "global";	//전역변수를 선언한다.
	function checkscope() {
		var scope = "local";	//전역 변수와 같은 이름으로 지역변수를 선언한다.
		return scope;			//전역 변수가 아닌 지역 변수를 반환한다.
	}
	checkscope()				//"local"

### 함수 유효범위와 끌어올림 (Hoisting) ###

	function test(o){
		var i = 0;							//i는 함수 전체에 걸쳐 정의된다.
		if(typeof o == "object") {
			var j = 0;						//j는 블록 뿐만 아니라 함수 전체에 걸쳐 정의 된다.
			for( var k=0; k < 10; k++){		//k는 반복문 외에도 함수 전체에 걸쳐 정의된다.
				console.log(k);				//숫자 0부터 9까지 출력한다.
			}
			console.log(k);					//k는 여전히 정의되어 있다.
											//10을 출력한다.
		}
		colsole.log(j);						//j는 정의되어 있고
											//초기화 되어 있지 않을 것이다.
	}


자바스크립트에서 함수의 유효범위는 이 함수 안에서 선언된 모든 변수가 함수 전체에 걸쳐 유효하다는 의미다. 흥미롭게도
<br> 이는 변수가 선언되기 전에도 유효하다. 이런 자바스크립트의 특징은 비공식저으로 끌어올림(hoisting) 이라고 알려져 있다

    var scope = "global";
	function f() {
		console.log(scope);		//global 이 아니라 undefined 이다. 
		var scope = "local";	//변수는 여기서 초기화 하지만 전역적으로 정의된다.	
		console.log(scope);		//"local" 을 출력한다.
	}
	
	지역변수는 함수 전체에 걸쳐 정의된다.
	즉 같은 이름의 전역 변수는 함수 전체에서 이 지역 변수에 의해 감춰진다.

### 프로퍼티로서의 변수 ###
    
전역 자바스크립트를 선언할 때, 실제로는 전역 객체의 프로퍼티를 정의하는 것이다.
<br>변수를 선언하려고 var를 사용한다면 생성된 프로퍼티는 수정 가능하지 않고 이것은 delete 연산자로 소멸시킬 수 없다
	

	var truevar =1;			//올바르게 선언한 전역 변수, 삭제할 수 없다.
	fakevar = 2; 			//삭제 가능한 전역 객체의 프로퍼티를 만든다.
	this.fakevar2 = 2;		//삭제 가능한 전역 객체의 프로퍼티를 만든다.
	delete truevar;			// false: 변수는 삭제할 수 없다.
	delete fakevar;			// true: 변수는 삭제된다.
	delete this.fakevar2;	// true: 변수는 삭제된다.


